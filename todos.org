#+TITLE: rewrite-cljs spike notes

* Todos
** TODO investigate
*** Also a problem for rewrite-cljc? https://github.com/borkdude/clj-kondo/issues/378
*** Borkdude keyword hack needed? https://github.com/borkdude/clj-kondo/blob/18d97a6c3ca7d5d9eba351aa4291fc828bd2b215/parser/clj_kondo/impl/rewrite_clj/parser/keyword.clj#L14
** TODO cleanup coerce record support
   See TODOs in code.
** TODO refine cljs namespace alias lookup
    Allow a client to provide a resolver fn rather than just a data binding.  The default will be clojure tools reader *ns-alias* but
    should be over-rideable to whatever the client wants.
** TODO make a coherent commit history from my spike experiments?
    My path was circuitous.. and based off rewrite-cljs... can/I/should/I do some major squashing?
** Testing
*** TODO study borkdude parser
    Distilled parser down to 140 lines: https://github.com/borkdude/sci/blob/master/src/sci/impl/parser.cljc
    Can we apply to rewrite-cljc?
*** TODO test under advanced optimizations
    initial tests under with node advanced pushed
*** TODO what is browser target for cljs?
    noticed that cljs-test-runner explicitly sets :browser for target
    my scripts override target to nil... and probably should not.
    what does it mean to run with a cljs target of nil in a browser?
*** TODO can I verify that I have not broken the api?
    Would like to automatically verify all is good for clj and cljs
    Sooo... get current cljs api, current clj api and compare with my api to make sure at least signatures are the same.
    Should not be terribly difficult but are there any tools for this?

    borkdude suggested maybe clj-kondo but I am not sure if that will work with import-vars

    borkdude [5:07 AM]
    @lread you can use clj-kondo for this, I could explain how. but since this is not part of a public contract, I haven’t documented this anywhere :wink: (edited)

    borkdude [5:45 AM]
    @lread quick REPL session:
    ```$ clj
    Clojure 1.10.0
    user=> (require '[clj-kondo.impl.cache :as cache])
    nil
    user=> (require '[clj-kondo.core :as clj-kondo])
    user=> (clj-kondo/run! {:lint ["/tmp/rewrite-clj/src"] :cache "/tmp/rewrite-clj"})
    ...
    user=> (clj-kondo/run! {:lint ["/tmp/rewrite-cljs-playground/src"] :cache "/tmp/playground"})
    ...
    user=> (cache/from-cache "/tmp/rewrite-clj/2019.06.02-alpha-SNAPSHOT" :clj ['rewrite-clj.parser.core])
    {rewrite-clj.parser.core {dispatch {:fixed-arities #{1}, :private? true, :ns rewrite-clj.parser.core, :name dispatch, :base-lang :clj, :lang :clj, :col 1, :row 17}, parse-next {:fixed-arities #{1}, :ns rewrite-clj.parser.core, :name parse-next, :base-lang :clj, :lang :clj, :col 1, :row 33}, parse-delim {:fixed-arities #{2}, :private? true, :ns rewrite-clj.parser.core, :name parse-delim, :base-lang :clj, :lang :clj, :col 1, :row 39}, parse-printables {:private? true, :ns rewrite-clj.parser.core, :name parse-printables, :base-lang :clj, :var-args-min-arity 3, :lang :clj, :col 1, :row 46}, :source :disk}}

    user=> (cache/from-cache "/tmp/playground/2019.06.02-alpha-SNAPSHOT" :cljc ['rewrite-clj.parser.core])
    {rewrite-clj.parser.core {:clj {dispatch {:fixed-arities #{1}, :private? true, :ns rewrite-clj.parser.core, :name dispatch, :base-lang :cljc, :lang :clj, :col 1, :row 16}, parse-next {:fixed-arities #{0}, :ns rewrite-clj.parser.core, :name parse-next, :base-lang :cljc, :lang :clj, :col 1, :row 32}, parse-delim {:fixed-arities #{1}, :private? true, :ns rewrite-clj.parser.core, :name parse-delim, :base-lang :cljc, :lang :clj, :col 1, :row 38}, parse-printables {:private? true, :ns rewrite-clj.parser.core, :name parse-printables, :base-lang :cljc, :var-args-min-arity 2, :lang :clj, :col 1, :row 45}}, :cljs {dispatch {:fixed-arities #{1}, :private? true, :ns rewrite-clj.parser.core, :name dispatch, :base-lang :cljc, :lang :cljs, :col 1, :row 16}, parse-next {:fixed-arities #{1}, :ns rewrite-clj.parser.core, :name parse-next, :base-lang :cljc, :lang :cljs, :col 1, :row 32}, parse-delim {:fixed-arities #{2}, :private? true, :ns rewrite-clj.parser.core, :name parse-delim, :base-lang :cljc, :lang :cljs, :col 1, :row 38}, parse-printables {:private? true, :ns rewrite-clj.parser.core, :name parse-printables, :base-lang :cljc, :var-args-min-arity 3, :lang :cljs, :col 1, :row 45}}, :source :disk}}```
    (edited)
    using the last two values, you could e.g. use https://github.com/lambdaisland/deep-diff to find differences (edited)
    please note that the cache namespace in clj-kondo is an implementation detail and might break in a future version :wink: (edited)

    martinklepsch [5:53 AM]
    A similar approach could be taken with the data in cljdoc but that's still a bit hard to get to unless you're willing to add this to cljdoc directly

    martinklepsch [5:54 AM]
    We should really get this API thing worked out :slightly_smiling_face:

    borkdude [5:54 AM]
    adding to cljdoc directly would make sense?

    martinklepsch [5:54 AM]
    oh yeah, that's what I'd love to see

    borkdude [5:54 AM]
    but then it would maybe not work for libraries that are forks and renamed versions of others
    unless you would make a “compare to” thingy

    martinklepsch [5:55 AM]
    like a "mechanical changelog" where you can compare two versions of the same lib and you see the (obvious) API differences (changed arities etc)

    borkdude [5:57 AM]
    yeah, but in lread’s case he’s doing a reworked version of some other library he’s trying to remain compatible with
    so it’s not the same lib, different clojars coordinates (edited)
    for accepting PRs this would also be useful (edited)

    martinklepsch [6:05 AM]
    ah right, that's a bit of a different thing

    borkdude [6:10 AM]
    but the automatic changelog is good to start with probably
    and later a “compare to” option can be added maybe

    martinklepsch [6:11 AM]
    yeah, or an API so people can do whatever :slightly_smiling_face:

    borkdude [6:34 AM]
    that’s even better. the automatic changelog could then use that API

    lread [8:09 AM]
    That’s interesting @borkdude! Thanks for sharing the details!

    borkdude [8:10 AM]
    @lread yeah, for one-off things it’s pretty easy to make a script out of it for your use case

    lread [8:19 AM]
    my original thought was, as @martinklepsch was suggesting, to look at publics via analyzers like cljdocs version of codox does. I thought this might work better because rewrite-clj makes use of a version of potemkin (hotly debated) import-vars. (edited)

    martinklepsch [8:19 AM]
    It always comes back to `import-vars` :smile:

    borkdude [8:22 AM]
    now that you mention it, clj-kondo should probably support that too :wink:
    does that also work in cljs?
    probably not :wink:

    lread [8:45 AM]
    I have created a version of import-vars for cljs within my rewrite-clj/rewrite-clj merge effort. I did it as a learning effort but since the concept is so contentious I questioned myslef often. :grimacing: It also led me here to cljdoc because the cljdoc codox fork needed to be updated to support cljs import-vars.

*** TODO review cljs specific tests
    - node_test.cljs
    - paredit_test.cljs - this is a cljs specific feature… will see if it fits into cli version as well
    - zip_tests.cljs
** Docs & API
*** TODO give guidance on the limitations of sexpr
    from discussion with @sogaiu and @borkdude on slack

    sogaiu [7:34 AM]
    not always easy to be brief but clear :slightly_smiling_face:
    @lread btw, i encountered a problem processing clojure's core.clj:

    ```(require
    '[rewrite-clj.zip :as rz]
    :reload-all)

    (def source-str
    (slurp "../clojure/src/clj/clojure/core.clj"))

    (def root-zloc
    (rz/of-string ;;(subs source-str 0 26232) ; no problem
    (subs source-str 0 26981) ; exception below
    {:track-position? true}))

    ;; ExceptionInfo unsupported operation for uneval-node ...
    (def strings
    (loop [zloc root-zloc
    results []]
    (if (rz/end? zloc)
    results
    (let [sexpr (rz/sexpr zloc)]
    (recur (rz/next zloc)
    (if (string? sexpr)
    (conj results zloc)
    results))))))```

    not sure, but i think the section of difficulty in core.clj is:

    ```;equals-based
    #_(defn =
    "Equality. Returns true if x equals y, false if not. Same as Java
    x.equals(y) except it also works for nil. Boxed numbers must have
    same type. Clojure's immutable data structures define equals() (and
    thus =) as a value, not an identity, comparison."
    {:inline (fn [x y] `(. clojure.lang.Util equals ~x ~y))
    :inline-arities #{2}
    :added "1.0"}
    ([x] true)
    ([x y] (clojure.lang.Util/equals x y))
    ([x y & more]
    (if (= x y)
    (if (next more)
    (recur y (first more) (next more))
    (= y (first more)))
    false)))```
    (edited)

    borkdude [7:47 AM]
    I think that makes sense, you can’t turn an uneval into a sexpr:
    ```$ clj
    Clojure 1.10.0
    user=> (require '[rewrite-clj.parser :as p])
    nil
    user=> (p/parse-string "#_foo")
    <uneval: "#_foo">
    user=> (require '[rewrite-clj.node :as n])
    nil
    user=> (n/sexpr (p/parse-string "#_foo"))
    Execution error (UnsupportedOperationException) at rewrite_clj.node.uneval.UnevalNode/sexpr (uneval.clj:6).
    null```

    borkdude [7:48 AM]
    or it should return `nil` maybe, but then you can’t distinguish between a token that represents nil

    borkdude [7:49 AM]
    ```$ clj
    Clojure 1.10.0
    user=> (require '[rewrite-clj.node :as n])
    nil
    user=> (require '[rewrite-clj.parser :as p])
    nil
    user=> (n/sexpr (p/parse-string "nil"))
    nil```

    borkdude [7:49 AM]
    same for comments:
    ```user=> (n/sexpr (p/parse-string ";; hello"))
    Execution error (UnsupportedOperationException) at rewrite_clj.node.comment.CommentNode/sexpr (comment.clj:6).
    null```

    lread [7:58 AM]
    Thinking about rewrite-clj sexpr feature is on my todo list. I guess it might be convenient but comes with limitation that should be documented.  I’m thinking that I should probably remove internal uses of sexpr because of these limitations. I’ll also have to think about cljs vs clj differences and how sexpr handles them - like ratio is only available in clj, differences in max integers, no char in cljs etc.

    lread [8:02 AM]
    My current thinking is rewrite-clj sexpr should be used cautiously if at all. What do you folks think?

    borkdude [8:07 AM]
    yeah, I try to avoid calling sexpr in clj-kondo as much as I can
    although I already filter out every uneval and comment before

    lread [8:14 AM]
    I guess if you are quite certain of what you are trying to sexpr you’ll probably be ok, but if you are sexpr-ing an unknown then maybe stay away from sexpr.

    borkdude [8:36 AM]
    yeah, exactly (edited)
    I have also made a few predicates like `symbol-token?` so I don’t need to sexpr to check if it’s a symbol
*** TODO push along my PR to support import-vars in cljs for cljdoc
*** TODO verify my guess at doc string for rewrite-clj prefix and suffix fns
*** TODO subedit could use some examples
** Review all TODOS in source code
** Language differences from library perspective
*** TODO parsing the language specific
   rewrite-clj should be able to parse and rewrite clojure and clojurescript from clojure or clojurescript.
   But there are differences between the languages.
   If I read in a clj/cljs file, make no changes, and spit it out, I should get the same result.
**** TODO what happens when we try to parse a ratio from ClojureScript
     from cljs repl:
     3/4
     Compile Exception: failed compiling constant: 3/4; clojure.lang.Ratio is not a valid ClojureScript constant.

     This is interesting:
     (edn/read-string "3/4")
     0.75
**** TODO test handling a very large int in cljs
     cljs.user=> 1234567890123456789012345678901234567890
     1.2345678901234568e+39

     (edn/read-string "1234567890123456789012345678901234567890")
     1.2345678901234568e+39
*** TODO experiment with sexprs across lang differences
*** TODO experiment with coerce across lang differences
*** TODO consider not using sepxr internally - I expect it will be an interop problemo
** Deployment
*** TODO deploy scripts
    Am moving away form lein to tools deps.  For cldoc-exerciser, I tried using maven to package and deploy.
    This seems to be a solid way to go and avoids the confusion of the many competing clojure libraries.
    Consider using garmamond to update the pom - doing that with maven was a bit awkward/slow.
*** TODO migrate to clj-commons
    This project will replace rewrite-cljs on clj-commons as rewrite-cljc
    Commit history - I have preserved commit history from rewrite-cljs which shares some history with rewrite-clj.
    Git issues - Also be nice to preserve git issues. I think I can transfer over any git issues I created here to clj-commons/rewrite-cljs.

* Later
** TODO consider allowing metadata to be a child
   of interest to borkdude - and more generally probably

   borkdude [8:36 AM]
   yeah, exactly (edited)
   I have also made a few predicates like `symbol-token?` so I don’t need to sexpr to check if it’s a symbol

   caveat is that there might be metadata on anything in clojure
   I wonder if it would have made better sense if the metadata was a child instead of a parent. it ~certainly~ maybe would have made my life easier, but I haven’t pondered the consequences of that (edited)

   lread [8:42 AM]
   interesting, we should probably eventually bring your predicates into rewrite-clj. Also interesting thought on metadata, would make it easier to parse the meat, right?

   borkdude [8:42 AM]
   right, for example: I expect the first node after `defn` to be a symbol, but in rewrite-clj it might be a metadata node with a symbol in it

   borkdude [8:43 AM]
   I would probably make metadata a field on the defrecord of every node or something
   but that might not work for rewriting (which I’m not concerned with) to the original expressions, including spaces, etc

   lread [8:44 AM]
   hmmm... yeah I see your point. It is worth thinking about more.

   borkdude [8:45 AM]
   I really like rewrite-clj btw. but I might need some clone for tuning towards clj-kondo for more performance… but not now, it’s already very fast (edited)
   what I basically do for nodes that might be metadata, is rip out the contents and store the metadata node as proper metadata on the node

   lread [8:48 AM]
   cool, it is very nice to have heavy users of rewrite-clj here like you and @sogaiu. Your feedback and ideas are greatly appreciated! :simple_smile:
   after I finish up a cljs ticket, I’ll get back on my rewrite-clj todo list and work toward the alpha release.

** TODO add some more support for sepxr
   of interest to sogaiu

   sogaiu [11:15 PM]
   two additional approach ideas for dealing with sexpr
   1) same as earlier idea of a new protocol, but name its method something like sexpr2, and don't remove sexpr from the Node protocol -- this is a change, but it doesn't break existing code?
   2) add a sexprable? method to the Node protocol -- all it does is tell you if it's safe to call sexpr
   in approach 1, may be existing sexpr implementations can be moved to external functions and those functions can be called from the protocol methods.  both the Node protocol sexpr and the new protocol sexpr2 can call these externalized functions.  newer code can use sexpr2 and other code can migrate to sexpr2 gradually.  satisfies? can be used to check whether it's safe to call sexpr2 before use.
   the earlier idea of just having sexprable? has the downside of maintainers having to remember to update it appropriately if node implementation details change in certain ways over time.

   sogaiu [11:41 PM]
   here is some scratch work for sexprable?

   ```(require '[rewrite-clj.node :as rn])

   (defn uneval?
   "Check whether a node represents an uneval."
   [node]
   (= (rn/tag node) :uneval))

   ;; following things will throw when sexpr is called:
   ;;
   ;;   comma,
   ;;   newline,
   ;;   whitespace
   ;;
   ;;   comment
   ;;
   ;;   uneval
   ;;
   ;; this could throw:
   ;;
   ;;   some reader nodes
   ;;
   ;; however, afaict, all currently implemented reader nodes (:var and :eval) don't throw by default
   (defn sexprable?
   "Check whether sexpr can be safely called on node."
   [node]
   (not (or (uneval? node)
   (rn/whitespace? node)
   (rn/comment? node))))```

   lread [12:29 AM]
   so, I don’t know @sogaiu. There are other reasons to stay away from sexpr. :grimacing: For example, let’s say your cljs app is sexpr-ing clj code that is not cljs compatible.  Like a ratio for example.  Looking at these kind of sexpr language incompatibilities is on my todo list.

   lread [12:35 AM]
   I would not go so far a deprecating sexpr but I’m thinking I’ll give strong guidance in docs on only using it in specific cases where you have a very good idea of what you are sexpr-ing. For that reason, I am wondering if further work on sexpr is prudent. Whadya think?
   but the extra predicates seem fine to me.

   sogaiu [2:17 AM]
   the case you described about a cljs app working with clj code is understandable, but it seems like the kind of thing where a warning would do.  not sure yet -- need to digest it more fully.

   i'm interested in hearing about other reasons to stay away from sexpr.  please share any further thoughts.

   i need to go through all the places i used sexpr in more detail -- perhaps i can manage that in the next day or so :slightly_smiling_face:

   may be you know this already, but for reference, all of the following rewrite-clj-using projects use sexpr (some much more than others):

   https://github.com/benedekfazekas/trin
   https://github.com/borkdude/clj-kondo
   https://github.com/clojure-emacs/refactor-nrepl
   https://github.com/kkinnear/zprint
   https://github.com/Olical/depot
   https://github.com/snoe/clojure-lsp
   https://github.com/weavejester/cljfmt

   i haven't looked in detail how it's used though.

   sogaiu [4:31 AM]
   @lread regarding extra predicates, borkdude has the following in clj-kondo's impl/utils.clj:

   ```(defn boolean-token? [node]
   (boolean? (:value node)))

   (defn char-token? [node]
   (char? (:value node)))

   (defn string-token? [node]
   (boolean (:lines node)))

   (defn number-token? [node]
   (number? (:value node)))

   (defn symbol-token? [node]
   (symbol? (:value node)))```

   i'm not sure about the naming (e.g. in some rewrite-clj/node/*.cljc there are comment?, comma?, etc.), but it'd be nice to have at least the string and symbol predicates -- may be having "-token" helps prevent collisions w/ clojure's built-in predicates?  having those would help with some of the usages of sexpr i'm finding.

   also, there are zip versions of list?, vector?, set?, map?, whitespace?, comment?, ... -- any thoughts on these and/or more of these types?  i know i use list?, vector?, and map?.  it would be nice to have something for string? and symbol? too -- though i also wonder about appropriate names for these.


   borkdude [4:32 AM]
   yeah, I’m not sure about the naming either, but since these are not part of my API I didn’t worry about it :slightly_smiling_face:
   also these predicates already assume that the node is a token. for efficiency

   sogaiu [4:33 AM]
   thanks for the clarifications :slightly_smiling_face:

   sogaiu [5:00 AM]
   one other usage of sexpr i appear to have repeatedly is for getting at values of things, e.g. string, symbol, first item in list.

   i noticed in clj-kondo's impl/util.clj the following:

   ```(defn symbol-call
   "Returns symbol of call"
   [expr]
   (when (= :list (node/tag expr))
   (let [first-child (-> expr :children first)
   ?sym (:value first-child)]
   (when (symbol? ?sym)
   ?sym))))```

   for string and symbol, i guess the guts of the -token predicates (e.g. (:value token)) above might work.  may be those guts, after being externalized into functions, can be called from the predicates?
** TODO consider speculative kaocha plugin
** TODO consider spec
* interop notes
  Differences between Clojure and ClojureScript
  - throws are bit different
  - catch Throwable
  - ns def must be verbose version
  - macros must be included differently
  - IMetaData and other base types different
  - format not part of cljs standard lib
  - no Character in cljs
  - no ratios in cljs
  - testing for NaN is different
  - different max numerics

* From rundis
   - http://rundis.github.io/blog/2015/clojurescript_performance_tuning.html
* Tool notes
** using figwheel main for testing
   Needs a dummy main to call if used only for testing
   Cannot use rebel readline for this project as rebel readline uses rewrite-clj and we get conflicts
