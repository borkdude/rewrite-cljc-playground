= Merging rewrite-clj and rewrite-cljs

rewrite-cljc is a merge of https://github.com/xsc/rewrite-clj[rewrite-clj] with https://github.com/clj-commons/rewrite-cljs[rewrite-cljs] giving us a one stop rewrite-clj shop for Clojure and ClojureScript developers.

== Goals
1. *Minimize API breakage*. Within reason, maintain API compatability with both rewrite-clj and rewrite-cljs. I'd like rewrite-cljc to potentially be a drop-in replacement for `rundis/rewrite-cljs` (actually now living at `clj-commons/rewrite-cljs`) and `xsc/rewrite-clj`.
2. *Feature parity*. rewrite-cljs has lagged behind rewrite-clj. Bring rewrite-cljs up to parity with rewrite-clj. Bring any rewrite-cljs specific features over to rewrite-clj.
3. *Preserve type hints*. I will respect and carry over existing type hinting in rewrite-clj and rewrite-cljs. I will not, at this time, evaluate if existing type hinting has value.
4. *Improve documentation*. I think that rewrite-clj documentation is good, but as I dig deeper into using the library and get feedback on Slack, I see places where guidance could be improved.
5. *Document design decisions*. I'm not sure what form this will take, but I do like projects that include histories of architectural and design decisions. Perhaps I'll adopt https://github.com/cljdoc/cljdoc/tree/master/doc/adr[adr ala cljdoc].
6. *Modernize/update test/build*. Look at what is available today and make a choice.
7. *Define library version scheme*. Evaluate options, pick one and document.
8. *Find home for this work*. Ideally, I think this work would be merged into `xsc/rewrite-clj`, but if that does not work out a reasonable alternative might be `clj-commons/rewrite-cljc` (which would be a replacement for a deprecated `clj-commons\rewrite-cljs`)

== Strategic Compromises
1. *Favor single code base*. I will favor single code base over maintaining ClojureScript specific optimizations from rewrite-cljs. These can be brought in at a later date if needed.
2. *Use generic exceptions*.  This is technically an API breakage, but I will switch to using the Clojure/ClojureScript agnostic `ex-info` for exceptions.
3. *Favor rewrite-clj features when there is overlap*. I currently only see one feature that overlaps between the two projects. rewrite-clj and rewrite-cljs both have positional (row/col) support. Base positional support in rewrite-clj is full featured and updates with any changes made, so we'll use it instead of rewrite-cljs's more primitive tools reader based positional support.  We will though carry over rewrite-cljs's higher level positional functions. This technically constitutes an API breakage for rewrite-cljs.

== Changes
=== Breaking
1. Minimum versions
** Clojure v1.9
** Java v1.8
** ClojureScript v10
4. Now using `ex-info` for exceptions
5. Base positional support for rewrite-cljs has been migrated over to rewrite-clj implementation

=== Potentially breaking
1. Switched to `clojure.tools.reader.edn`
2. Potential performance hit for rewrite-cljs. Some rewrite-cljs specific optimizations dropped in favor of single code base.

=== Accretive
The following non-breaking additions were made
TODO

=== Neutral
1. Docs now generated by cljdoc
** direct zipper functions (`right*`, `left*`, `up*`, etc) now show correct arguments.
** ``import-var``ed protocol functions now point to correct source code
2. Continuous integration is now handled by CircleCI
3. Test tooling now uses:
** figwheel main for development cljs testing
** kaocha for clj testing
4. Dependencies are now in `deps.edn`

== Feature Differences
No ability to read from files when using rewrite-cljc from ClojureScript.

== Observations
=== Wow, a lot of libraries use rewrite-clj
During this work, I noticed how pervasive rewrite-clj usage is. This discovery often took the form of "Why isn't x working? Oh, it uses rewrite-clj and my things are getting confused." Examples of x:

. https://github.com/bhauman/figwheel-main[figwheel-main] which uses https://github.com/bhauman/rebel-readline[rebel-readline] which uses rewrite-clj
. https://github.com/Olical/depot[depot] uses rewrite-clj
. https://github.com/clojure-emacs/cider[cider] which can optionally enable https://github.com/clojure-emacs/clj-refactor.el[clj-refactor] which brings in rewrite-clj

== Analysis & Implementation Notes
=== What is the public API?
rewrite-clj purposefully only generated documentation for specific namespaces. It is reasonable to assume that these namespaces represent the public API.

* `rewrite-clj.parse`
* `rewrite-clj.node`
* `rewrite-clj.zip`

I am not sure why `rewrite-clj.custom-zipper` is included in the documented public API, because its functionality is exposed through `rewrite-clj.zip`, I expect this was perhaps an oversight.

Because what is public versus what is private was not stressed strongly, I frequently see private APIs used in code.

=== Library version scheme
I see plenty of version scheme variations out there these days. Here are a few examples I find interesting:

[cols="10,40,20,~",options="header"]
|====
|Project
|Scheme
|Example
|Observation

|https://github.com/clojure/clojurescript/releases[ClojureScript]
|major.minor.<commit count since major.minor>
|`1.10.520`
|Tracks Clojure version.

|https://github.com/borkdude/clj-kondo/releases[clj-kondo]
|yyyy-mm-dd-qualifier
|`2019.07.05-alpha`
|Freshness built into version.

|https://github.com/cljdoc/cljdoc[cljdoc]
|major.minor.<commit count>-<short git sha>
|`0.0.1315-c9e9a73`
|The short-sha safeguards against any potential confusion with duplicate commit counts for builds on different machines.
|====

rewrite-clj is not a new project. I feel the version should reflect at least some familiarity with its current scheme.

As of this writing the current version of rewrite-clj is `0.6.2`. I am guessing that the 0 is an unused version element, and we have a `0.major.minor` scheme.

rewrite-cljc is going to switch to a ClojureScript-ish scheme. +
It will use a `major.minor.<commit count since major.minor>-<qualifier>` scheme. +
Our first version will be `1.0.42-alpha` where `42` is just a wild guess right now.


=== Source directory layout
When I first started to experiment with a cljc version of rewrite-clj, my directory layout looked like:
[svgbob]
....
|-src
| |-clj
| | '-rewrite-clj
| |-cljs
| | '-rewrite-clj
| '-cljc
|   '-rewrite-clj
|-test
| |-clj
| | '-rewrite-clj
| |-cljs
| | '-rewrite-clj
| '-cljc
|   '-rewrite-clj
....

After a certain amount of work, I realized the majority of the code was cljc so opted for the much simpler:
[svgbob]
....
|-src
| '-rewrite-clj
|-test
| '-rewrite-clj
....

=== ClojureScript namespace clashes
ClojureScript uses Google Closure under the hood. Because of the way Google Closure handles namespaces, some namespaces that work fine on Clojure clash under ClojureScript. Some rewrite-clj namespaces clash for ClojureScript, for example:

* `rewrite-clj.zip/find`
* `rewrite-clj.zip.find`

The original rewrite-cljs author worked around this problem by renaming namespaces to avoid the clashes.

[%autowidth]
|===
|library|namespace

|rewrite-clj
|rewrite-clj.node.coerce

|rewrite-cljs
|rewrite-clj.node.coerce[yellow-background]**r**

|rewrite-clj
|rewrite-clj.node.string

|rewrite-cljs
|rewrite-clj.node.string[yellow-background]**z**

|rewrite-clj
|rewrite-clj.zip.edit

|rewrite-cljs
|rewrite-clj.zip.edit[yellow-background]**z**

|rewrite-clj
|rewrite-clj.zip.find

|rewrite-cljs
|rewrite-clj.zip.find[yellow-background]**z**

|rewrite-clj
|rewrite-clj.zip.remove

|rewrite-cljs
|rewrite-clj.zip.remove[yellow-background]**z**

|rewrite-clj
|rewrite-clj.zip.seq

|rewrite-cljs
|rewrite-clj.zip.seq[yellow-background]**z**
|===

None of these namespaces are part of public APIs, but because I see a lot of code that uses these internal namespaces, I decided to preserve the existing naming for both Clojure and ClojureScript. ClojureScript will continue to use the `rewrite-cljs` renames, and Clojure will get both versions.

=== S-expressions
rewrite-clj allows parsed Clojure/ClojureScript/EDN to be converted back and forth to s-expressions.  Example from a REPL session:

[source,clojure]
----
user=> (require '[rewrite-clj.zip :as z])
nil
user=> (def zipper (z/of-string "[1 2 3]"))  // <1>
#'user/zipper
user=> zipper
[<vector: [1 2 3]> {:l [], :pnodes [<forms: [1 2 3]>], :ppath nil, :r nil}]
user=> (def s (z/sexpr zipper)) // <2>
#'user/s
user=> s
[1 2 3]
user=> (require '[rewrite-clj.node :as n])
nil
user=> (n/coerce s) // <3>
<vector: [1 2 3]>
----
<1> parse string to rewrite-clj nodes and create zipper
<2> convert rewrite-clj node at current location in zipper to s-expression
<3> convert s-expression to rewrite-clj node

While I expect this can be quite convenient, it does come with caveats which were not stressed in the original documentation.

1. What happens when we try to `sexpr` Clojure specific features from ClojureScript? For example, ratios are available in Clojure but not ClojureScript.
2. If you try to `sexpr` something that cannot be converted into an s-epxression an exception will be thrown.

My guidance is use `sexpr` in only in specific cases, where you know ahead of time what you are parsing. General blind use of `sexpr` is not recommended.

For rewrite-cljc itself, I have removed internal problematic uses of `sepxr`.

=== Which reader?
rewrite-clj makes use of Clojure's reader.  There are a few choices though:

1. `clojure.tools.reader`
2. `clojure.tools.reader.edn`
3. `clojure.reader`
4. `clojure/reader-string`

As I understand it, `clojure.tools.reader.edn` is the safest choice and I have updated rewrite-cljc to use it in all cases.


=== Clojure/ClojureScript interop
Where I felt I could get away with it, I localized Clojure/ClojureScript differences in the `rewrite-clj.interop` namespace.

=== Potemkin import-vars
rewrite-clj makes use of a slightly modified version of https://github.com/ztellman/potemkin#import-vars[Potemkin import-vars]. The intent of import-vars is to make it easy to expose a public API from a set of internal namespaces.

When I first reviewed its usage in rewrite-clj, I found import-vars to be quite elegant. I have since learned that there is quite a bit of strong opinion in the Clojure community surrounding import-vars. Not all of it is rosy.

Also, there is no ClojureScript version of import-vars.

That said, I decided, at least for now, to honor the original rewrite-clj codebase and carry on with it. To be honest, this gave me the (the apparently too tempting to resist) opportunity to learn how to write a version of import-vars for ClojureScript. This led me to discover that while cljdoc did cope fine with import-vars trickery for Clojure code, it did not have any support for it for ClojureScript code. I made the necessary changes to cljdoc's fork of codox, when Martin Klepsch finds the time, he will integrate my pull request.

I also extended import-vars to rewrite-clj's purposes by adding a facility to rename imported vars and adapt docstrings.

All is not entirely rainbows and unicorns yet,

. I am not certain, but I think import-vars might not play well we cloverage. I gave it a quick try and it failed miserably. My first suspect is import-vars.
. Linters like joker and clj-kondo don't know what import-vars intent is and can report false positives.

=== Positional support
rewrite-clj

1. added a custom zipper to optionally track row/col within your Clojure/ClojureScript/EDN file.
2. expresses positions as a `[row-number col-number]` vector.

rewrite-cljs

1. made use of the positional support provided by Clojure tools reader.
2. exposed a couple of functions to search by position.
3. expressed positions as a `{:row row-number :col col-number}` map

Because the positional support in rewrite-clj tracks row/col even after zipper modifications, we use it instead of rewrite-cljs's implementation.
We:

1. continue to support both rewrite-clj vector rewrite-cljs map notations for positions on function parameters.
2. use vector notation for position on function returns. I personally prefer the map notation, but, as a rule, favor rewrite-clj over rewrite-cljs because rewrite-clj is the more widely used library and thus changes affect more users.
3. include rewrite-cljs's positional functions: `rewrite-clj.zip/find-last-by-pos` and `rewrite-clj.zip/find-tag-by-pos` .

The breaking change for ClojureScript is that it must now create the zipper with positional support enabled, for example: `(z/of-string "[1 2 3]" {:track-position true})`

=== Namespaced maps
At the time of this writing, rewrite-clj had released partial support for namespaced maps. I attempted to complete this support in a pull request which has not, and may never, be merged into rewrite-clj.

As part of this merge I decided to include full namespaced map support which meant:
1. including a refined version of my rewrite-clj pull request
2. adding namespaced maps support for ClojureScript

Refresher on namespaced maps:
[source, clojure]
----
#:prefix-ns{:a 1}  // <1>
#::ns-alias{:b 2}  // <2>
#::{:c 3}          // <3>
----
<1> `prefix-ns` is applied directly to map keys
<2> `ns-alias` is a valid namespace alias that is applied to map keys
<3> current namespace is applied to map keys

The rewrite-clj namespaced map support tried to resolve namespaces. Resolution is only necessary for `sexpr` and have adjusted the code accordingly.

I'm not sure resolution is necessary for prefix and alias resolve namespace maps at all. If we assume we are not in job of validating source code, we
can simply apply the prefix-ns or the ns-alias to the keys.

TODO: Where things get interesting is the auto-resolve namespace. It resolves to the current namespace. Would some tooling want to `sexpr` an auto-resolve namespaced map, but not want to bother with binding the current *ns*? I am thinking maybe?
